<template>
  <Teleport
    v-if="isVisible"
    to="#modal-destination"
  >
    <div
      class="generic-modal"
      role="dialog"
      :class="stateClasses"
    >
      <div
        class="backdrop"
        @click="onClickOutside"
      />
      <div
        ref="container"
        class="container"
        :style="{ width: props.width }"
      >
        <button
          v-if="props.showClose"
          ref="closeBtn"
          class="close"
          :aria-label="t('verbs.close')"
          @click.prevent="closeModal"
        >
          <CloseIcon />
        </button>
        <div
          ref="content"
          class="modal-content"
        >
          <slot />
        </div>
      </div>
    </div>
  </Teleport>
</template>

<script setup lang="ts">
import CloseIcon from '~/components/common/New/Icons/CloseIcon.vue'
import FocusTrap from '~/utils/FocusTrap'
import changeElementVOVisibility from '~/utils/changeElementVOVisibility'
import scrollLock from '~/utils/scroll-lock'

const props = withDefaults(
  defineProps<{
    visible: boolean
    isFullscreen: boolean
    width: string | undefined
    showClose: boolean
  }>(),
  {
    visible: false,
    isFullscreen: false,
    width: undefined,
    showClose: true,
  },
)

const emit = defineEmits(['update:visible', 'close', 'open'])

const { t } = useI18n()
const isVisible = ref(props.visible)
watch(
  () => props.visible,
  (val) => {
    isVisible.value = val
  },
)
watch(isVisible, (val) => {
  emit('update:visible', val)
})

const container = ref<HTMLElement | null>(null)
const content = ref<HTMLElement | null>(null)
const closeBtn = ref<HTMLElement | null>(null)
let lastFocusItem: HTMLElement | null = null
let focusTrapInstance: FocusTrap

const stateClasses = computed(() => ({
  'modal-fullscreen': props.isFullscreen,
  'modal-standard': !props.isFullscreen,
  'modal-open': isVisible.value,
  'modal-with-close': props.showClose,
}))

const onShow = () => {
  nextTick(() => {
    if (container.value) scrollLock.lockScroll(container.value)
    focusCloseButton().then(() => {
      focusTrapInstance.updateFocusContainer(container.value)
      focusTrapInstance.start()
      if (container.value) changeElementVOVisibility.hide(container.value)
    })
  })
}

const onHide = () => {
  if (container.value) scrollLock.unlockScroll(container.value)
  focusTrapInstance.stop()
  if (lastFocusItem) {
    lastFocusItem.focus({ preventScroll: true })
    lastFocusItem = null
  }
  emit('close')
  if (container.value) changeElementVOVisibility.show(container.value)
}

watch(isVisible, (val) => {
  if (val) onShow()
  else onHide()
})

onMounted(() => {
  focusTrapInstance = new FocusTrap()
  document.addEventListener('keydown', onKeydown)
})

onBeforeUnmount(() => {
  if (isVisible.value && container.value) scrollLock.unlockScroll(container.value)
  document.removeEventListener('keydown', onKeydown)
  focusTrapInstance.destroy()
})

const closeModal = () => {
  isVisible.value = false
}

const onClickOutside = () => {
  closeModal()
}

const onKeydown = (event: KeyboardEvent) => {
  const { metaKey = false, ctrlKey = false, key } = event
  if (!isVisible.value) return
  if (key === 'a' && (metaKey || ctrlKey)) {
    event.preventDefault()
    selectContent()
  }
  if (key === 'Escape') {
    event.preventDefault()
    closeModal()
  }
}

const selectContent = () => {
  if (content.value) window.getSelection()?.selectAllChildren(content.value)
}

const focusCloseButton = async () => {
  lastFocusItem = document.activeElement as HTMLElement
  await nextTick()
  if (closeBtn.value) closeBtn.value.focus()
  emit('open')
}
</script>

<style scoped lang="scss">
// @import "docc-render/styles/_core.scss";

$-modal-close-font-size: 40px;
$-modal-close-font-size-medium: 32px;
$modal-close-color: light-color(figure-gray-tertiary) !default;

.generic-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  margin: 0;
  z-index: 11000; // Make sure modals are positioned on top.
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  background: none;
  overflow: auto;
}

// modal-type
.modal {
  &-fullscreen {
    align-items: stretch;

    // expand the container to be 100% of the modal
    .container {
      margin: 0;
      flex: 1;
      width: 100%;
      height: 100%;
      padding-top: env(safe-area-inset-top);
      padding-right: env(safe-area-inset-right);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
    }
  }

  &-standard {
    padding: 20px;

    .container {
      padding: 60px;
      border-radius: $big-border-radius;
      @include prefers-dark {
        background: rgb(29, 29, 31);
      }
    }

    @include breakpoint(small) {
      padding: 0;
      align-items: stretch;
      .container {
        margin: 20px 0 0;
        padding: 50px 30px;
        flex: 1;
        width: 100%;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
      }
    }
  }
}

.backdrop {
  overflow: auto;
  background: var(--backdrop-background, rgba(0, 0, 0, 0.4));
  -webkit-overflow-scrolling: touch;
  width: 100%;
  height: 100%;
  position: fixed;
}

.container {
  @include breakpoint-content;
  background: var(
    --colors-generic-modal-background,
    var(--color-generic-modal-background)
  );
  z-index: 1;
  position: relative;
  overflow: auto;
  max-width: 100%;
}

.close {
  position: absolute;
  z-index: 9999;
  top: 22px;
  left: 22px;
  width: 17px;
  height: 17px;
  color: $modal-close-color;
  cursor: pointer;
  background: none;
  border: 0;
  display: flex;
  align-items: center;

  .close-icon {
    fill: currentColor;
    width: 100%;
    height: 100%;
  }
}

// themes

.theme {
  &-dark {
    .container {
      background: dark-color(fill);

      .close {
        color: dark-color(figure-gray-tertiary);
      }
    }
  }

  &-code {
    .container {
      background-color: var(--code-background, var(--color-code-background));
    }
  }
}
</style>
